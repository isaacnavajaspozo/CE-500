# üß† Nginx es un servidor web y proxy reverso eficiente y ligero, optimizado para manejar altas cargas y tr√°fico concurrente.
#=========================================================================================================================
[‚õ©Ô∏èWHITE WHALE]::
# Documentaci√≥n configurar Node 		: https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-ubuntu-20-04-es?
# Documentaci√≥n configurar Nginx 		: https://carlosazaustre.es/como-configurar-nginx-con-node-js-en-produccion?
# Documentaci√≥n certificado 			: https://medium.com/@ali_97803/deploy-de-una-app-de-express-js-con-github-actions-usando-nginx-en-modo-https-855126f93164#82a4
# Documentaci√≥n no-oficial certificados		: https://rlodeiro.info/blog/certificado-autofirmado/
# Documentaci√≥n oficial de Lets Encrypt		: https://letsencrypt.org/
# Documentaci√≥n OpenSSL				: https://docs.openssl.org/3.0/man7/migration_guide/
# Documentaci√≥n de mongodb	   		: https://www.mongodb.com/docs/
#						: https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-debian/?
#						: https://www.mongodb.com/docs/manual/reference/configuration-options/#systemlog
#						: https://www.mongodb.com/docs/manual/

#=========================================================================================================================
[‚õ©Ô∏èINSTALACIONES]::
# instalaciones 
apt update
apt upgrade -y

# entro en el volumen e instalo el script
cd /docker-volume
apt install vim -y
vim script-00.sh
# i - (shift + bot√≥n derecho):
--------------------------------------------------------------------------------------
    # c√≥digo de /SCRIPTS/script-00.sh de este github
--------------------------------------------------------------------------------------

# doy permisos y hago la instalaci√≥n
chmod +x script-00.sh
./script-00.sh
source ~/.bashrc

#=========================================================================================================================
[‚õ©Ô∏èSERVIDOR NGINX EXPRESS.JS]:
üßë‚Äçüéì NODE  :: Entorno de ejecuci√≥n para JavaScript en el servidor. Permite ejecutar c√≥digo JavaScript fuera del navegador.
üßë‚Äçüéì NGINX :: Servidor web y proxy inverso. Es ligero, r√°pido y ampliamente utilizado para actuar como proxy inverso para aplicaciones.
üßë‚Äçüéì PM2   :: Gestor de procesos para aplicaciones Node.js. Mantiene las aplicaciones en ejecuci√≥n, maneja ciclos de vida y garantiza su disponibilidad, incluso despu√©s de fallos o reinicios del servidor.

## ‚ö†Ô∏è Como no dispongo actualmente de ning√∫n dominio real voy a utilizar el host de mi Linux, para que llegue a funcionar tengo que forzar el host de Windows:
	> <IP_LINUX>	<HOST_MAQUINA_NGINX>
## Configuro express en el servidor de manera simple para comprobar que funcione::
## configuraci√≥n express

# Instalo Node.js y npm 
sudo apt update
sudo apt install -y nodejs npm
node -v
npm -v

# instalo nginx 
apt install -y nginx
systemctl status nginx

# Instalaci√≥n inicial:
	mkdir /var/www/express && cd /var/www/express
	cd express
	npm init -y
	npm install express
	npm install --save-dev typescript @types/node @types/express ts-node
	# Para ayudar a TypeScript a comprender los tipos utilizados en bibliotecas externas
	npm install --save-dev @types/node @types/express
	# Para que los cambios en TypeScript se cambie autom√°ticamente sin reiniciar el servidor
	npm install --save-dev nodemon

# Configuraci√≥n de TypeScript tsconfig.json:
vim tsconfig.json
-----------------------------------------------------------------------
{
    "compilerOptions": {
        "target": "ES6",
        "module": "commonjs",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "include": [
        "app/**/*.ts"
    ],
    "exclude": [
        "node_modules"
    ]
}
-----------------------------------------------------------------------

# Creo archivo nodemon.json:
vim nodemon.json
-----------------------------------------------------------------------
{
  "watch": ["app"],
  "ext": "ts",
  "exec": "ts-node app/index.ts"
}
-----------------------------------------------------------------------
	
# Modifico archivo package.json:
vim package.json
-----------------------------------------------------------------------
"scripts": {
  "start": "nodemon"
}
-----------------------------------------------------------------------

# Creo un archivo /app/index.ts:
mkdir app
npm install express mongoose
cd app
vim index.ts
-----------------------------------------------------------------------
import express, { Request, Response } from 'express';
import mongoose from 'mongoose';

const app = express();
const port = 3000;

const mongoURI = 'mongodb://localhost:27017/tu_base_de_datos'; 
mongoose.connect(mongoURI, { useNewUrlParser: true, useUnifiedTopology: true })
  .then(() => {
    console.log('üë®‚Äçüíª Connect to MongoDB');
  })
  .catch(err => {
    console.error('Error:', err);
  });

app.get('/', (req: Request, res: Response) => {
  res.send('Hello Ilerna, i can write TypeScript with Express.js!');
});

app.listen(port, () => {
  console.log(`Server is running at http://localhost:${port}`);
});
-----------------------------------------------------------------------

# modifico el host para que la web se vea v√≠a web simulando al dominio : pruebas.local
hostnamectl set-hostname <HOST_SERVIDOR>
vim /etc/hosts
----------------------------------------------------------------------------
127.0.0.1   localhost
<IP_DEL_SERVIDOR_PRIVADA>   <HOST_SERVIDOR>
	
# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
----------------------------------------------------------------------------

# compruebo el host modificado 
hostname

# Ejecuto la aplicaci√≥n
cd /var/www/express
npm run start

# pruebo a entrar en http://<IP_DEL_SERVIDOR>:3000
# si consigo entrar vuelco el proyecto de express.js que quiero que muestre

## Configurar Nginx:
# configuro un proxy inverso
# Un proxy inverso es un servidor que recibe las solicitudes de los clientes y las redirige a uno o varios servidores internos, ocultando su identidad.
systemctl restart nginx
vim /etc/nginx/sites-available/express
----------------------------------------------------
server {
    listen 80;
    server_name <HOST_SERVIDOR>:3000;			# dominio o IP

    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
----------------------------------------------------

# creo enlace simbolico
sudo ln -s /etc/nginx/sites-available/express /etc/nginx/sites-enabled/

# reinicio nginx
sudo systemctl restart nginx

# Una vez llegados a este punto y visto que funciona Nginx con Express.js && Typescript, migro el proyecto que he desarrollado, en este mismo GitHub al servidor de desarrollo.
# A partir de aora voy a crear un proyecto con Nginx con Express.js y con Typescript en una configuraci√≥n cluster con tres puertos diferentes.

#=========================================================================================================================
[‚õ©Ô∏èINSTALACI√ìN DE PM2]:
# PM2 no solo es √∫til para gestionar procesos en producci√≥n, sino que tambi√©n es muy eficaz para gestionar el ciclo de vida de la aplicaci√≥n, incluyendo el despliegue (deploy), la gesti√≥n de procesos, y la configuraci√≥n de producci√≥n.

## process manager:
# Para mantenerlo activo despu√©s de cerrar la terminal
npm install -g pm2

cd /var/www/express
# Voy a utilizar una forma m√°s simple de crear el pm2 ya que luego creo el archivo ecosystem.config.js para sustituir esta configuraci√≥n, 
# la primera vez lo probe as√≠ por eso lo dejo comentado, por lo que este apartado me lo salto de configurar...
	# pm2 start npm --name "express" -- run start --watch 		# --watch sirve para reiniciar la aplicaci√≥n si hay cambios y que no se caiga la aplicaci√≥n
	# pm2 startup 							# Configura PM2 para que inicie tu aplicaci√≥n autom√°ticamente en caso de reinicio del servidor
	# pm2 save							# guarda la configuraci√≥n
	# otros comandos pm2	
	# pm2 delete express
	# pm2 restart express

# creo un archivo de configuraci√≥n para pm2
cd /var/www/express
vim ecosystem.config.js
----------------------------------------------------
module.exports = {
  apps: [
    {
      name: 'express',                                  // Nombre del proceso
      script: 'node_modules/ts-node/dist/bin.js',       // Archivo principal del servidor, utilizo ts-node para ejecutar archivos TypeScript.
      args: 'app/index.ts',                             // Ejecuto el archivo Typescript
      instances: 3,                                     // N√∫mero de instancias para escalar la aplicaci√≥n (clusters)
      exec_mode: 'cluster',
      autorestart: true,                                // Reiniciar autom√°ticamente si el proceso falla
      max_restarts: 3,                                  // Limitar a 3 reinicios seguidos, para no saturar la aplicaci√≥n en caso de fallo
      restart_delay: 2000,                              // Esperar 1 segundo entre reinicios
      iwatch: ["app"],
      gnore_watch: ["node_modules"],                   // ignoro archivos que no quiero que evalue si cambian
      wait_ready: true,
      listen_timeout: 3000,
      watch_options: {
         usePolling: true                               // Usar polling puede ayudar si tu sistema de archivos no detecta los cambios en tiempo real
      },
      env: {
        NODE_ENV: 'production'                          // Puedo forzar una variable de entorno dentro del archivo .env para afirmar que cuando se ejecute pm2 sea en producci√≥n
      }
    }
  ],

  // # Puedo gestionar un repositorio git desde aqu√≠
  //deploy: {
  //  production: {
  //    user: 'deploy_user',
  //    host: 'your.server.com',
  //    ref: 'origin/master',
  //    repo: 'git@github.com:yourrepo.git',
  //    path: '/var/www/yourapp',
  //    'post-deploy': 'npm install && pm2 reload ecosystem.config.js --env production',
  //  }
  //}
};

module.exports = {
	apps: [
	  {
	    name: 'express',                                  // Nombre del proceso
	    script: 'node_modules/ts-node/dist/bin.js',       // Archivo principal del servidor, utilizo ts-node para ejecutar el archivo TypeScript.
	    args: 'app/index.ts',                             // Ejecuto el archivo Typescript
	    instances: 1,                                     // N√∫mero de instancias para escalar la aplicaci√≥n (clusters)
	    autorestart: true,                                // Reiniciar autom√°ticamente si el proceso falla
	    max_restarts: 5,                                  // Limitar a 5 reinicios seguidos, para no saturar la aplicaci√≥n en caso de fallo
	    restart_delay: 2000,                              // Esperar 1 segundo entre reinicios
	    watch: true,                                      // Observar cambios en el directorio
	    ignore_watch: ["node_modules"],                   // ignoro archivos que no quiero que evalue si cambian
	    env: {
	      NODE_ENV: 'production'                          // Puedo forzar una variable de entorno dentro del archivo .env para afirmar que cuando se ejecute pm2 sea en producci√≥n
	    }
	  }
	],
	
	// # Puedo gestionar un repositorio git desde aqu√≠
	//deploy: {
	//  production: {
	//    user: 'deploy_user',
	//    host: 'your.server.com',
	//    ref: 'origin/master',
	//    repo: 'git@github.com:yourrepo.git',
	//    path: '/var/www/yourapp',
	//    'post-deploy': 'npm install && pm2 reload ecosystem.config.js --env production',
	//  }
	//}
};
----------------------------------------------------

# reinicio mi app con PM2
pm2 start ecosystem.config.js

# Para comprobar el listado de pm2
pm2 ps

# comprobar los fallos del proyecto express
pm2 logs express

#=========================================================================================================================
[‚õ©Ô∏èINSTALACI√ìN DE MONGODB]:
# importar la clave p√∫blica de MongoDB
wget -O mongodb. - https://www.mongodb.org/static/pgp/server-6.0.asc

# a√±adir el repositorio de MongoDB
echo "deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/debian $(lsb_release -sc)/mongodb-org/6.0 main" | sudo tee /etc/apt/sources.list.d/mongodb-org-6.0.list

# actualizo
sudo apt update

# instalar mongodb
sudo apt install -y mongodb-org

# iniciar servicio mongodb
sudo systemctl start mongod
sudo systemctl enable mongod
sudo systemctl status mongod

# acceder al shell mongo
# mongo
mongosh

# crear una base de datos
use nombre_de_base_de_datos

# crear un usuario con permisos
db.createUser({
  user: "nombre_usuario",
  pwd: "contrase√±a_segura",
// roles seg√∫n sea necesario...
  roles: [
    { role: "read", db: "nombre_de_base_de_datos" },           // Solo lectura
    { role: "readWrite", db: "nombre_de_base_de_datos" },      // Lectura y escritura
    { role: "dbAdmin", db: "nombre_de_base_de_datos" },        // Administraci√≥n de la base de datos
    { role: "dbOwner", db: "nombre_de_base_de_datos" },        // Propietario de la base de datos
    { role: "clusterAdmin", db: "admin" },                      // Administraci√≥n de cl√∫steres (para MongoDB en cl√∫ster)
    { role: "backup", db: "admin" },                            // Permisos de respaldo
    { role: "restore", db: "admin" },                           // Permisos de restauraci√≥n
    { role: "userAdmin", db: "nombre_de_base_de_datos" },       // Administraci√≥n de usuarios en la base de datos
    { role: "userAdminAnyDatabase", db: "admin" },              // Administraci√≥n de usuarios en cualquier base de datos
    { role: "root", db: "admin" },                              // Acceso completo (superusuario)
    { role: "readAnyDatabase", db: "admin" },                   // Lectura en cualquier base de datos
    { role: "readWriteAnyDatabase", db: "admin" }               // Lectura y escritura en cualquier base de datos
  ]
})

# sugerencia:
# Usa el rol readWrite para usuarios que solo necesiten leer y escribir en una base de datos.
# Usa el rol dbAdmin para administradores de base de datos.

# comprobar los usuarios
show users

# autenticaci√≥n y conexi√≥n con el usuario
# Configurar el cortafuegos
vim /etc/mongod.conf
----------------------------------------------------
security:
  authorization: "enabled" 		# autenticaci√≥n con usuario existente
...
net:
  bindIp: 127.0.0.1, 192.168.1.100  	# Permitir solo IPs locales y 192.168.1.100
...
net:
  http:
    enabled: false  			# Deshabilitar la interfaz HTTP
----------------------------------------------------

# reinicio servicio
systemctl restart mongod

# conectarse con el usuario creado
mongo -u nombre_usuario -p contrase√±a_segura --authenticationDatabase nombre_de_base_de_datos



## otras configuraciones de seguridad
# encriptaci√≥n en reposo: MongoDB Enterprise ofrece encriptaci√≥n de datos en reposo, lo cual cifra los datos almacenados en disco. Si usas la versi√≥n comunitaria, puedes usar una soluci√≥n externa de cifrado.
# encriptaci√≥n en tr√°nsito: Configura TLS/SSL para cifrar el tr√°fico de la base de datos entre los clientes y el servidor MongoDB.
vim /etc/mongod.conf
----------------------------------------------------
net:
  ssl:
    mode: requireSSL  # Forzar la encriptaci√≥n de datos en tr√°nsito
    PEMKeyFile: /ruta/al/certificado.pem
...

# monitorizaci√≥n del Acceso
systemLog:
  destination: file
  path: /var/log/mongodb/mongod.log
  logAppend: true
----------------------------------------------------

# con los datos de la base de datos mongodb modifico el archivo 
vim /var/www/express/app/index.ts
----------------------------------------------------
...
const mongoURI = 'mongodb://localhost:27017/nombre_de_base_de_datos'; 
...
----------------------------------------------------

# reinicio pm2
cd /var/www/express
pm2 start ecosystem.config.js

# Finalmente puedo acceder desde un Windows al CLI (Command Line Interface) descargando MongoDB Compass
https://www.mongodb.com/try/download/compass

#=========================================================================================================================
[‚õ©Ô∏èINSTALAR CERTIFICADO]:
# certificado con dominio local
‚ö†Ô∏è Para un dominio local como el mio necesito un certificado autofirmado

# creo la carpeta
mkdir /var/www/express/letsencrypt
cd /var/www/express/letsencrypt

## .key :: (clave privada)
# Genero una clave privada
openssl genpkey -algorithm RSA -out pruebas.local.key -aes256

## .csr :: (Solicitud de firma de certificado)
# Genero un archivo de solicitud de firma de certificado (CSR)
# En un entorno real, una vez generado mi CSR desde mi servidor lo tengo que enviar a la empresa de venta de dominio (como Namecheap) o Autoridad Certificadora (CA) y ellos me lo validan y me devuelven un .crt
openssl req -new -key pruebas.local.key -out pruebas.local.csr

## .crt o .pfx o .pem :: (clave p√∫blica)
# Genero el certificado autofirmado con caducidad de 1 a√±o (solo lo genero en el caso que sean pruebas, los "certificados autofirmados" se hacen cuando el dominio no es real)
# En un entorno real, deber√≠a enviar la CSR a una Autoridad de Certificaci√≥n (CA) y utilizar el certificado que me proporcionar√≠an.
openssl x509 -req -days 365 -in pruebas.local.csr -signkey pruebas.local.key -out pruebas.local.crt

# En el caso de caducarse, en un entorno real, tengo que generar otro CSR y repitiendo el proceso con la Autoridad Certificadora (CA).

# edito la configuraci√≥n de mi sitio Nginx
cd /etc/nginx/sites-available
vim express
----------------------------------------------------
# https
server {
    listen 443 ssl;
    server_name pruebas.local;

    ssl_certificate /var/www/express/letsencrypt/pruebas.local.crt;
    ssl_certificate_key /var/www/express/letsencrypt/pruebas.local.key.nopass;

    location / {
        proxy_pass http://app_cluster;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
# http
server {
    listen 80;
    server_name pruebas.local;
    return 301 https://$host$request_uri;
}
----------------------------------------------------

# agrego la configuraci√≥n del cluster en el archivo principal de nginx - al final del bloque de configuraci√≥n de http 
vim /etc/nginx/nginx.conf
----------------------------------------------------
...
upstream app_cluster {
    server 127.0.0.1:3000;
    # server 127.0.0.1:3001;
    # server 127.0.0.1:3002;
}

include /etc/nginx/conf.d/*.conf;
include /etc/nginx/sites-enabled/*;
...
----------------------------------------------------

# verifico la configuraci√≥n
sudo nginx -t

# reinicio el servicio de nginx
sudo systemctl restart nginx

# para comprobar el certificado
openssl s_client -connect pruebas.local:443


-
‚ö†Ô∏è si me da un error en el certificado privado pruebo a quitarle la contrase√±a
‚ö†Ô∏è si no me a dado ning√∫n error o quiero dejar la encriptaci√≥n ya he finalizado 100% la configuraci√≥n
# creo una nueva clave
sudo openssl rsa -in /var/www/express/letsencrypt/pruebas.local.key -out /var/www/express/letsencrypt/pruebas.local.key.nopass

# modifico mi archivo y agrego la nueva clave
sudo vim /etc/nginx/sites-available/express
----------------------------------------------------
...
	ssl_certificate_key /var/www/express/letsencrypt/pruebas.local.key.nopass;
	# ssl_certificate_key /var/www/express/letsencrypt/pruebas.local.key;
...
----------------------------------------------------

# comprueba el archivo de certificado 
openssl x509 -in /var/www/express/letsencrypt/pruebas.local.crt -text -noout

#=========================================================================================================================
[‚õ©Ô∏èMATO PROCESOS SI HAY FALLO]:
# compruebo los procesos en mi puerto
lsof -i :3000

# mato el proceso
sudo kill -9 <PID>

