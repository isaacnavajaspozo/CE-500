# üß† Nginx es un servidor web y proxy reverso eficiente y ligero, optimizado para manejar altas cargas y tr√°fico concurrente.
# üêß Esta m√°quina la voy a utilizar como honeypot y me va a registrar decoys, simulaci√≥n de rutas y gesti√≥n con mongodb (sin paquetes externos).
#=========================================================================================================================
[üöÄWHITE WHALE]::
# Documentaci√≥n configurar Node 		: https://www.digitalocean.com/community/tutorials/how-to-set-up-a-node-js-application-for-production-on-ubuntu-20-04-es?
# Documentaci√≥n configurar Nginx 		: https://carlosazaustre.es/como-configurar-nginx-con-node-js-en-produccion?
# Documentaci√≥n certificado 			: https://medium.com/@ali_97803/deploy-de-una-app-de-express-js-con-github-actions-usando-nginx-en-modo-https-855126f93164#82a4
# Documentaci√≥n no-oficial certificados		: https://rlodeiro.info/blog/certificado-autofirmado/
# Documentaci√≥n oficial de Lets Encrypt		: https://letsencrypt.org/
# Documentaci√≥n OpenSSL				: https://docs.openssl.org/3.0/man7/migration_guide/
# Documentaci√≥n de mongodb	   		: https://www.mongodb.com/docs/
#						: https://www.mongodb.com/docs/manual/tutorial/install-mongodb-on-debian/
#						: https://www.mongodb.com/docs/manual/reference/configuration-options/#systemlog
#						: https://www.mongodb.com/docs/manual/

#=========================================================================================================================
[üöÄINSTALACIONES]::
# instalaciones 
apt update
apt upgrade -y

# creo una carpeta en el contenedor e instalo el script
mkdir /KIRIBAKO && cd /KIRIBAKO
apt install vim -y
vim script-00.sh
# i - (shift + bot√≥n derecho):
--------------------------------------------------------------------------------------
    # c√≥digo de /SCRIPTS/script-00.sh de este github
--------------------------------------------------------------------------------------

# doy permisos y hago la instalaci√≥n
chmod +x script-00.sh
./script-00.sh
source ~/.bashrc

#=========================================================================================================================
[üöÄSERVIDOR NGINX EXPRESS.JS]:
üßë‚Äçüéì NODE  :: Entorno de ejecuci√≥n para JavaScript en el servidor. Permite ejecutar c√≥digo JavaScript fuera del navegador.
üßë‚Äçüéì NGINX :: Servidor web y proxy inverso. Es ligero, r√°pido y ampliamente utilizado para actuar como proxy inverso para aplicaciones.
üßë‚Äçüéì PM2   :: Gestor de procesos para aplicaciones Node.js. Mantiene las aplicaciones en ejecuci√≥n, maneja ciclos de vida y garantiza su disponibilidad, incluso despu√©s de fallos o reinicios del servidor.

## Configuro express en el servidor de manera simple para comprobar que funcione::
## configuraci√≥n express

# Instalo Node.js y npm 
sudo apt update
sudo apt install -y nodejs npm
node -v
npm -v

# instalo nginx 
apt install -y nginx
systemctl status nginx

# Instalaci√≥n inicial:
	mkdir /var/www/express && cd /var/www/express
	npm init -y
	npm install express
	npm install --save-dev typescript @types/node @types/express ts-node
	# Para ayudar a TypeScript a comprender los tipos utilizados en bibliotecas externas
	npm install --save-dev @types/node @types/express
	# Para que los cambios en TypeScript se cambie autom√°ticamente sin reiniciar el servidor
	npm install --save-dev nodemon

# Configuraci√≥n de TypeScript tsconfig.json:
vim tsconfig.json
-----------------------------------------------------------------------
{
    "compilerOptions": {
        "target": "ES6",
        "module": "commonjs",
        "strict": true,
        "esModuleInterop": true,
        "skipLibCheck": true,
        "forceConsistentCasingInFileNames": true
    },
    "include": [
        "app/**/*.ts"
    ],
    "exclude": [
        "node_modules"
    ]
}
-----------------------------------------------------------------------

# Creo archivo nodemon.json:
vim nodemon.json
-----------------------------------------------------------------------
{
  "watch": ["app"],
  "ext": "ts",
  "exec": "ts-node app/index.ts"
}
-----------------------------------------------------------------------
	
# Modifico archivo package.json:
vim package.json
-----------------------------------------------------------------------
"scripts": {
  "start": "nodemon",
...
}
-----------------------------------------------------------------------

# Creo un archivo /app/index.ts:
mkdir app
npm install express mongoose
cd app
vim index.ts
-----------------------------------------------------------------------
import express, { Request, Response } from 'express';

const app = express();
const port = 3000;

app.get('/', (req: Request, res: Response) => {
  res.send('Hello Ilerna, I can write TypeScript with Express.js!');
});

app.listen(port, () => {
  console.log(`üöÄ Server is running at http://localhost:${port}`);
});
-----------------------------------------------------------------------

# ‚ö†Ô∏è esto es opcional : si quiero cambiar el host para entrar desde otra url a la web (por defecto ser√° vm-nginx)
# modifico el host para que la web se vea v√≠a web simulando al dominio : pruebas.local
# hostnamectl set-hostname <HOST_SERVIDOR>
# vim /etc/hosts
# ----------------------------------------------------------------------------
# 127.0.0.1   localhost
# <IP_DEL_SERVIDOR_PRIVADA>   <HOST_SERVIDOR>
	
# # The following lines are desirable for IPv6 capable hosts
# ::1     localhost ip6-localhost ip6-loopback
# ff02::1 ip6-allnodes
# ff02::2 ip6-allrouters
----------------------------------------------------------------------------

# compruebo el host 
hostname

# Ejecuto la aplicaci√≥n
cd /var/www/express
npm run start

# pruebo a entrar en http://<IP_DEL_SERVIDOR>:3000
http://vm-nginx:3000
# si consigo entrar vuelco el proyecto de express.js que quiero que muestre

## Configurar Nginx:
# configuro un proxy inverso
# Un proxy inverso es un servidor que recibe las solicitudes de los clientes y las redirige a uno o varios servidores internos, ocultando su identidad.
systemctl restart nginx
vim /etc/nginx/sites-available/express
----------------------------------------------------
server {
    listen 80;
    server_name <HOST_SERVIDOR>:3000;			# dominio o IP

    location / {
        proxy_pass http://localhost:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
----------------------------------------------------

# creo enlace simbolico
sudo ln -s /etc/nginx/sites-available/express /etc/nginx/sites-enabled/

# reinicio nginx
sudo systemctl restart nginx

# Una vez llegados a este punto y visto que funciona Nginx con Express.js && Typescript, migro el proyecto que he desarrollado, en este mismo GitHub al servidor de desarrollo.
# A partir de aora voy a crear un proyecto con Nginx con Express.js y con Typescript en una configuraci√≥n cluster.

#  ‚ö†Ô∏è es buena pr√°ctica, si no voy a utilizar ipv6, comentar la siguiente l√≠nea o a la larga me crear√° un error
# error : "nginx: [emerg] socket() [::]:80 failed (97: Address family not supported by pro..."
vim /etc/nginx/sites-enabled/default
----------------------------------------------------
...
# listen [::]:80;
...
----------------------------------------------------
systemctl restart nginx
systemctl status nginx

#=========================================================================================================================
[üöÄINSTALACI√ìN DE PM2]:
# PM2 no solo es √∫til para gestionar procesos en producci√≥n, sino que tambi√©n es muy eficaz para gestionar el ciclo de vida de la aplicaci√≥n, incluyendo el despliegue (deploy), la gesti√≥n de procesos, y la configuraci√≥n de producci√≥n.

## process manager:
# Para mantenerlo activo despu√©s de cerrar la terminal
npm install -g pm2

cd /var/www/express
# Voy a utilizar una forma m√°s simple de crear el pm2 ya que luego creo el archivo ecosystem.config.js para sustituir esta configuraci√≥n, 
# la primera vez lo probe as√≠ por eso lo dejo comentado, por lo que este apartado me lo salto de configurar...
	# pm2 start npm --name "express" -- run start --watch 		# --watch sirve para reiniciar la aplicaci√≥n si hay cambios y que no se caiga la aplicaci√≥n
	# pm2 startup 							# Configura PM2 para que inicie tu aplicaci√≥n autom√°ticamente en caso de reinicio del servidor
	# pm2 save							# guarda la configuraci√≥n
	# otros comandos pm2	
	# pm2 delete express
	# pm2 restart express

# creo un archivo de configuraci√≥n para pm2
cd /var/www/express
vim ecosystem.config.js
----------------------------------------------------
module.exports = {
	apps: [
	  {
	    name: 'express',                                  // Nombre del proceso
	    script: 'node_modules/ts-node/dist/bin.js',       // Archivo principal del servidor, utilizo ts-node para ejecutar el archivo TypeScript.
	    args: 'app/index.ts',                             // Ejecuto el archivo Typescript
	    instances: 1,                                     // N√∫mero de instancias para escalar la aplicaci√≥n (clusters)
	    autorestart: true,                                // Reiniciar autom√°ticamente si el proceso falla
	    max_restarts: 5,                                  // Limitar a 5 reinicios seguidos, para no saturar la aplicaci√≥n en caso de fallo
	    restart_delay: 2000,                              // Esperar 1 segundo entre reinicios
	    watch: true,                                      // Observar cambios en el directorio
	    ignore_watch: ["node_modules"],                   // ignoro archivos que no quiero que evalue si cambian
	    env: {
	      NODE_ENV: 'production'                          // Puedo forzar una variable de entorno dentro del archivo .env para afirmar que cuando se ejecute pm2 sea en producci√≥n
	    }
	  }
	],
	
	// # Puedo gestionar un repositorio git desde aqu√≠
	//deploy: {
	//  production: {
	//    user: 'deploy_user',
	//    host: 'your.server.com',
	//    ref: 'origin/master',
	//    repo: 'git@github.com:yourrepo.git',
	//    path: '/var/www/yourapp',
	//    'post-deploy': 'npm install && pm2 reload ecosystem.config.js --env production',
	//  }
	//}
};
----------------------------------------------------

# reinicio mi app con PM2
pm2 start ecosystem.config.js

# Para comprobar el listado de pm2
pm2 ps

# comprobar los fallos del proyecto express
pm2 logs express

#=========================================================================================================================
[üöÄINSTALACI√ìN DE MONGODB]:
# importar la clave p√∫blica de MongoDB
sudo apt-get install gnupg curl
curl -fsSL https://www.mongodb.org/static/pgp/server-8.0.asc | \
   sudo gpg -o /usr/share/keyrings/mongodb-server-8.0.gpg \
   --dearmor

# a√±adir el repositorio de MongoDB
echo "deb [ signed-by=/usr/share/keyrings/mongodb-server-8.0.gpg ] http://repo.mongodb.org/apt/debian bookworm/mongodb-org/8.0 main" | sudo tee /etc/apt/sources.list.d/mongodb-org-8.0.list

# actualizo
sudo apt update

# instalar mongodb
sudo apt install -y mongodb-org

# iniciar servicio mongodb
sudo systemctl start mongod
sudo systemctl enable mongod
sudo systemctl status mongod

# acceder al shell mongo
mongosh

# crear una base de datos
use usuarios

# crear un usuario con permisos
# db.createUser({
#   user: "nombre_usuario",
#   pwd: "contrase√±a_segura",
# // roles seg√∫n sea necesario...
#   roles: [
#     { role: "read", db: "nombre_de_base_de_datos" },           // Solo lectura
#     { role: "readWrite", db: "nombre_de_base_de_datos" },      // Lectura y escritura
#     { role: "dbAdmin", db: "nombre_de_base_de_datos" },        // Administraci√≥n de la base de datos
#     { role: "dbOwner", db: "nombre_de_base_de_datos" },        // Propietario de la base de datos
#     { role: "clusterAdmin", db: "admin" },                      // Administraci√≥n de cl√∫steres (para MongoDB en cl√∫ster)
#     { role: "backup", db: "admin" },                            // Permisos de respaldo
#     { role: "restore", db: "admin" },                           // Permisos de restauraci√≥n
#     { role: "userAdmin", db: "nombre_de_base_de_datos" },       // Administraci√≥n de usuarios en la base de datos
#     { role: "userAdminAnyDatabase", db: "admin" },              // Administraci√≥n de usuarios en cualquier base de datos
#     { role: "root", db: "admin" },                              // Acceso completo (superusuario)
#     { role: "readAnyDatabase", db: "admin" },                   // Lectura en cualquier base de datos
#     { role: "readWriteAnyDatabase", db: "admin" }               // Lectura y escritura en cualquier base de datos
#   ]
# })

# sugerencia:
# Usa el rol readWrite para usuarios que solo necesiten leer y escribir en una base de datos.
# Usa el rol dbAdmin para administradores de base de datos.

db.createUser({
  user: "user",
  pwd: "Bijowodo*402",
 roles: [
    { role: "readWrite", db: "usuarios" }
  ]
})

db.createUser({
  user: "admin",
  pwd: "Riujtrgdo*789",
 roles: [
    { role: "dbAdmin", db: "usuarios" }
  ]
})

# comprobar los usuarios
show users
exit

# autenticaci√≥n y conexi√≥n con el usuario
# Configurar el cortafuegos
vim /etc/mongod.conf
----------------------------------------------------
security:
  authorization: "enabled" 		        # autenticaci√≥n con usuario existente
...
net:
  bindIp: 127.0.0.1,192.168.1.1/24  	# Permitir solo IPs locales y 192.168.1.100
...
net:
  http:
    enabled: false  			            # Deshabilitar la interfaz HTTP
----------------------------------------------------

# reinicio servicio
systemctl restart mongod

# conectarse con el usuario creado
#mongo -u nombre_usuario -p contrase√±a_segura --authenticationDatabase nombre_de_base_de_datos
mongosh -u user -p Bijowodo*402 --authenticationDatabase usuarios


## otras configuraciones de seguridad
# encriptaci√≥n en reposo: MongoDB Enterprise ofrece encriptaci√≥n de datos en reposo, lo cual cifra los datos almacenados en disco. Si usas la versi√≥n comunitaria, puedes usar una soluci√≥n externa de cifrado.
# encriptaci√≥n en tr√°nsito: Configura TLS/SSL para cifrar el tr√°fico de la base de datos entre los clientes y el servidor MongoDB.
vim /etc/mongod.conf
----------------------------------------------------
net:
  ssl:
    mode: requireSSL  # Forzar la encriptaci√≥n de datos en tr√°nsito
    PEMKeyFile: /ruta/al/certificado.pem
...

# monitorizaci√≥n del Acceso
systemLog:
  destination: file
  path: /var/log/mongodb/mongod.log
  logAppend: true
----------------------------------------------------

# con los datos de la base de datos mongodb modifico el archivo 
vim /var/www/express/app/index.ts
----------------------------------------------------
...
const mongoURI = 'mongodb://localhost:27017/nombre_de_base_de_datos'; 
...
----------------------------------------------------

# reinicio pm2
cd /var/www/express
pm2 start ecosystem.config.js

# Finalmente puedo acceder desde un Windows al CLI (Command Line Interface) descargando MongoDB Compass
https://www.mongodb.com/try/download/compass

#=========================================================================================================================
[üöÄCOMPROBAR LA CONEXI√ìN CON MONGOO]:
# vuelvo a editar el archivo de configuraci√≥n de express con una conexi√≥n simple de mongo
cd /var/www/express/app
vim index.ts
-----------------------------------------------------------------------
import express, { Request, Response } from 'express';
import mongoose from 'mongoose';

const app = express();
const port = 3000;

const mongoURI = 'mongodb://localhost:27017/tu_base_de_datos'; 
mongoose.connect(mongoURI, { useNewUrlParser: true, useUnifiedTopology: true })
  .then(() => {
    console.log('üë®‚Äçüíª Connect to MongoDB');
  })
  .catch(err => {
    console.error('Error:', err);
  });

app.get('/', (req: Request, res: Response) => {
  res.send('Hello Ilerna, i can write TypeScript with Express.js!');
});

app.listen(port, () => {
  console.log(`Server is running at http://localhost:${port}`);
});
-----------------------------------------------------------------------

#=========================================================================================================================
[üöÄINSTALAR CERTIFICADO]:
# certificado con dominio local
‚ö†Ô∏è Para un dominio local como el mio necesito un certificado autofirmado

# creo la carpeta
mkdir /var/www/express/letsencrypt
cd /var/www/express/letsencrypt

## .key :: (clave privada)
# Genero una clave privada
openssl genpkey -algorithm RSA -out pruebas.local.key -aes256

## .csr :: (Solicitud de firma de certificado)
# Genero un archivo de solicitud de firma de certificado (CSR)
# En un entorno real, una vez generado mi CSR desde mi servidor lo tengo que enviar a la empresa de venta de dominio (como Namecheap) o Autoridad Certificadora (CA) y ellos me lo validan y me devuelven un .crt
openssl req -new -key pruebas.local.key -out pruebas.local.csr

## .crt o .pfx o .pem :: (clave p√∫blica)
# Genero el certificado autofirmado con caducidad de 1 a√±o (solo lo genero en el caso que sean pruebas, los "certificados autofirmados" se hacen cuando el dominio no es real)
# En un entorno real, deber√≠a enviar la CSR a una Autoridad de Certificaci√≥n (CA) y utilizar el certificado que me proporcionar√≠an.
openssl x509 -req -days 365 -in pruebas.local.csr -signkey pruebas.local.key -out pruebas.local.crt

# En el caso de caducarse, en un entorno real, tengo que generar otro CSR y repitiendo el proceso con la Autoridad Certificadora (CA).

# edito la configuraci√≥n de mi sitio Nginx
cd /etc/nginx/sites-available
vim express
----------------------------------------------------
# https
server {
    listen 443 ssl;
    server_name pruebas.local;

    ssl_certificate /var/www/express/letsencrypt/pruebas.local.crt;
    ssl_certificate_key /var/www/express/letsencrypt/pruebas.local.key.nopass;

    location / {
        proxy_pass http://app_cluster;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }
}
# http
server {
    listen 80;
    server_name pruebas.local;
    return 301 https://$host$request_uri;
}
----------------------------------------------------

# agrego la configuraci√≥n del cluster en el archivo principal de nginx - al final del bloque de configuraci√≥n de http 
vim /etc/nginx/nginx.conf
----------------------------------------------------
...
upstream app_cluster {
    server 127.0.0.1:3000;
    # server 127.0.0.1:3001;
    # server 127.0.0.1:3002;
}

include /etc/nginx/conf.d/*.conf;
include /etc/nginx/sites-enabled/*;
...
----------------------------------------------------

# verifico la configuraci√≥n
sudo nginx -t

# reinicio el servicio de nginx
sudo systemctl restart nginx

# para comprobar el certificado
openssl s_client -connect pruebas.local:443


-
‚ö†Ô∏è si me da un error en el certificado privado pruebo a quitarle la contrase√±a
‚ö†Ô∏è si no me a dado ning√∫n error o quiero dejar la encriptaci√≥n ya he finalizado 100% la configuraci√≥n
# creo una nueva clave
sudo openssl rsa -in /var/www/express/letsencrypt/pruebas.local.key -out /var/www/express/letsencrypt/pruebas.local.key.nopass

# modifico mi archivo y agrego la nueva clave
sudo vim /etc/nginx/sites-available/express
----------------------------------------------------
...
	ssl_certificate_key /var/www/express/letsencrypt/pruebas.local.key.nopass;
	# ssl_certificate_key /var/www/express/letsencrypt/pruebas.local.key;
...
----------------------------------------------------

# comprueba el archivo de certificado 
openssl x509 -in /var/www/express/letsencrypt/pruebas.local.crt -text -noout

#=========================================================================================================================
[üöÄCONFIGURACI√ìN HONEYPOT]::
# configuro nuevas rutas que sean trampas
# üêù honeypot rutas 
vim /var/www/express/app/index.ts
-----------------------------------------------------------------------
import express, { Request, Response, NextFunction } from 'express';ts    c /var/www/express/app/index.ts                                                                                                                                     import fs from 'fs';
import path from 'path';
import mongoose from 'mongoose';

const app = express();
const port = 3000;
const mongoURI = 'mongodb://localhost:27017/tu_base_de_datos';

// ruta del log
const logPath = '/KIRIBAKO/log/express_access.log';

// registro de accesos
app.use((req: Request, res: Response, next: NextFunction) => {
  const timestamp = new Date().toISOString();
  const ip = req.headers['x-forwarded-for'] || req.socket.remoteAddress;
  const userAgent = req.headers['user-agent'] || 'N/A';
  const log = `[${timestamp}] ${ip} ‚Üí ${req.method} ${req.url} | UA: ${userAgent}\n`;

  // directorio existente
  const logDir = path.dirname(logPath);
  if (!fs.existsSync(logDir)) {
    fs.mkdirSync(logDir, { recursive: true });
  }

  fs.appendFileSync(logPath, log);
  console.log(log.trim());
  next();
});

// rutas
app.get('/', (req: Request, res: Response) => {
  res.send('Hello Ilerna, I can write TypeScript with Express.js!');
});

// simulando una web ghost (blogger)
app.get('/ghost', (req: Request, res: Response) => {
  res.send(`
    <html>
      <head>
        <title>Ghost</title>
      </head>
      <body>
        <h1>Ghost</h1>
        <form action="/login" method="post">
          <label>Email:</label>
          <input type="email" name="email" required>
          <br>
          <label>Password:</label>
          <input type="password" name="password" required>
          <br>
          <button type="signin">Sign in</button>
        </form>
      </body>
    </html>
  `);
});

app.post('/login', (req, res) => {
  const { email, password } = req.body;
  res.send('Inicio de sesi√≥n exitoso!');
});

app.get('/.git', (req: Request, res: Response) => {
  res.send('User without permissions');
});

app.get('/datos-sensibles', (req: Request, res: Response) => {
  res.send('User without permissions');
});

// latencia simulada
app.get('/config.bak', async (req, res) => {
  await new Promise(resolve => setTimeout(resolve, 30000));
  res.status(200).send('Configuration backup file');
});

// falsa API
app.get('/api/v1/internal/debug', (req, res) => {
  res.json({ debug: true, verbose: true, token: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYXBpX2tleSIsImlhdCI6MTY5OTk5OTk5OSwiZXhwIjoxNzAwMDAzNTk5fQ.kG5jVslP1ZwqT-7IFBzvMZ8F9KHtrQzYxh2v_m6k4v4' });
});

// imprimo por consola la conexi√≥n
mongoose.connect(mongoURI)
  .then(() => {
    console.log('üë®‚Äçüíª Connect to MongoDB');
  })
  .catch(err => {
    console.error('Error:', err);
  });

app.listen(port, () => {
  console.log(`üöÄ Server is running at http://localhost:${port}`);
});
-----------------------------------------------------------------------


# üêù honeypot para decoys :: scanners (falsificar archivos de configuraci√≥n)
# agrego archivos falsos de posibles ataques, les asocio un tama√±o virtual y monitorizo su interactuaci√≥n 
echo "Backup falso" > /var/www/express/app/db_backup.bson && truncate -s 1455M /var/www/express/app/db_backup.bson
echo "Log falso" > /var/www/express/app/access.log && truncate -s 321M /var/www/express/app/access.log
echo "Mongodb falso" > /var/www/express/mongodb. && truncate -s 987M /var/www/express/mongodb.

# instalo inotify para escuchar en vivo si el archivo se abierto
sudo apt install inotify-tools

# creo script para evaluar con inotify
mkdir /KIRIBAKO/log/
touch /KIRIBAKO/log/honypot-monitor.txt
vim honypot-monitor.sh
-----------------------------------------------------------------------
#!/bin/bash

# Lista de archivos a monitorear (separados por espacios)
archivos_a_monitorear=(
  "/var/www/express/app/db_backup.bson"
  "/var/www/express/app/access.log"
  "/var/www/express/mongodb."
)

log="/KIRIBAKO/log/honypot-monitor.txt"

# Verifica que todos los archivos existan
for archivo in "${archivos_a_monitorear[@]}"; do
  if [ ! -f "$archivo" ]; then
    echo "‚ùå El archivo no existe: $archivo"
    exit 1
  fi
done

# Ejecuta inotifywait sobre todos los archivos
inotifywait -m -e open "${archivos_a_monitorear[@]}" | while read path action file; do
  echo "$(date '+%Y-%m-%d %H:%M:%S') - Se abri√≥: $path$file" >> "$log"
done
-----------------------------------------------------------------------
chmod +x honypot-monitor.sh

# para que no se vea como un systemctl y dejarlo ejecutado en segundo plano 
# lo malo de este m√©todo es que cada vez que se reinicia el servidor hay que pasar este comando
sudo /KIRIBAKO/honypot-monitor.sh &

# para comprobar que se esta ejecutando
ps aux | grep monitor.sh


# üêù honeypot para Mongodb
# voy a monitorizar si alguien se loguea en la base de datos o realiza operaciones como find, save, update
# agrego las siguientes lineas al archivo de configuracion
vim /etc/mongod.conf
-----------------------------------------------------------------------
...
systemLog:
  destination: file
  path: /KIRIBAKO/log/mongod.log
  logAppend: true
  verbosity: 1 					# Nivel 1 para registrar conexiones y operaciones b√°sicas

security:
  authorization: enabled  			# Opcional, pero recomendable para monitoreo por usuario

operationProfiling:
  mode: all
  slowOpThresholdMs: 1  			# Considera como "lenta" cualquier operaci√≥n que dure m√°s de 1 ms
...
-----------------------------------------------------------------------

# reinicio los seervicios
sudo systemctl restart mongod


#=========================================================================================================================
[üöÄMODIFICO MAC]::
# modifico MAC para simular una MAC de interface iDRAC (DELL), como si fuese un servidor rack DELL

ip link set dev eth0 down
# para asignar una MAC creible : https://standards-oui.ieee.org
ip link set dev eth0 address F8:BC:12:7E:4A:D9
ip link set dev eth0 up

# comprobar el cliente de la MAC
https://macaddresslookup.io/es?search=00:14:22:1A:2B:3C

# comprobar los cambios
ip a

# modifico el archivo de red
vim /etc/network/interfaces
-----------------------------------------------------------------------
...
iface eth0 inet dhcp
hwaddress ether F8:BC:12:7E:4A:D9
...
-----------------------------------------------------------------------

# creo un servicio para que no deje de ser permanente la MAC temporal (aunque reinicie)
vim /etc/systemd/system/fix-mac.service
-----------------------------------------------------------------------
[Unit]
Description=Set static MAC address for eth0
After=network-pre.target
Before=network.target

[Service]
Type=oneshot
ExecStart=/usr/sbin/ip link set dev eth0 address f8:bc:12:7e:4a:d9
RemainAfterExit=true

[Install]
WantedBy=multi-user.target
-----------------------------------------------------------------------

sudo systemctl daemon-reexec
sudo systemctl daemon-reload
sudo systemctl enable fix-mac.service
sudo systemctl start fix-mac.service


#=========================================================================================================================
[üöÄMATO PROCESOS SI HAY FALLO]:
# compruebo los procesos en mi puerto
lsof -i :3000

# mato el proceso
sudo kill -9 <PID>

